# SubTerra Docker Compose
#
# Architecture:
#   backend  — Lightweight PHP container: Laravel API + Vue SPA + queue workers
#   fenics   — Heavy FEniCS container: mesh generation + simulation (per-job)
#   redis    — Queue broker + cache
#
# The backend dispatches work to the FEniCS image via `docker run`.
# The fenics service only exists to *build* the image; it does not stay running.
#
# Usage:
#   docker compose build                     # Build both images
#   docker compose up -d backend redis       # Start web + queue
#
# The queue workers inside the backend container automatically spawn
# fenics containers for each job via the Docker socket.

services:

  # ─── Redis (Queue + Cache) ───────────────────────────────────────────
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 3
    restart: unless-stopped

  # ─── Laravel Backend + Vue Frontend ──────────────────────────────────
  # Lightweight PHP container — NO FEniCS, NO Python, NO gmsh.
  # Serves the API, the SPA, and runs queue workers that dispatch
  # simulation work to the fenics container.
  backend:
    build:
      context: .
      dockerfile: docker/backend/Dockerfile
    ports:
      - "8000:8000"
    environment:
      APP_NAME: SubTerra
      APP_ENV: production
      APP_DEBUG: "false"
      APP_URL: http://localhost:8000
      DB_CONNECTION: sqlite
      DB_DATABASE: /var/www/html/database/database.sqlite
      QUEUE_CONNECTION: redis
      REDIS_HOST: redis
      REDIS_PORT: 6379
      CACHE_DRIVER: redis
      SESSION_DRIVER: redis
      SUBTERRA_RUNNER_MODE: docker
      SUBTERRA_FENICS_IMAGE: subterra-fenics
      # Name of the Docker volume shared between backend and fenics containers.
      # Must match the volume name defined below (volumes -> jobs_data -> name).
      SUBTERRA_DOCKER_JOBS_VOLUME: subterra_jobs_data
    volumes:
      # Mount Docker socket so queue workers can spawn FEniCS containers
      - /var/run/docker.sock:/var/run/docker.sock
      # Shared named volume for job work directories.
      # Both the backend and the dynamically spawned fenics containers
      # reference this volume by its explicit name (subterra_jobs_data).
      - jobs_data:/var/www/html/storage/app/jobs
    depends_on:
      redis:
        condition: service_healthy
    restart: unless-stopped

  # ─── FEniCS Simulation (build-only) ─────────────────────────────────
  # Heavy scientific image — Python, FEniCS, gmsh, dolfin-convert.
  # NOT a long-running service. The backend queue workers spawn:
  #   docker run --rm -v subterra_jobs_data:/subterra/jobs \
  #     -e JOB_ID=<uuid> subterra-fenics \
  #     python3 -m src.mesh_runner --params /subterra/jobs/<uuid>/parameter.json
  fenics:
    build:
      context: .
      dockerfile: docker/fenics/Dockerfile
    image: subterra-fenics
    # This service is only used to build the image.
    # It exits immediately after printing a success message.
    command: ["echo", "FEniCS image built successfully"]
    profiles:
      - build

volumes:
  redis_data:
  jobs_data:
    # Explicit name so the backend can reference it in `docker run -v` commands
    # without worrying about the compose project name prefix.
    name: subterra_jobs_data
